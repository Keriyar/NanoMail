# 基于 Rust 与 Slint 的轻量级 Windows Gmail 通知客户端设计与实现

---

## 摘要

随着电子邮件在日常工作与生活中的重要性日益增加，用户对邮件通知的实时性与便捷性提出了更高要求。传统的 Web 端 Gmail 虽然功能强大，但存在响应延迟、资源占用高等问题。本文设计并实现了 NanoMail——一款基于 Rust 语言和 Slint UI 框架的轻量级 Windows Gmail 通知客户端。

本系统采用 OAuth2.0 协议实现安全的用户授权，通过 Gmail API 获取未读邮件数量与用户信息，并采用 AES-256-GCM 算法结合机器指纹对敏感 Token 进行本地加密存储。系统实现了混合驱动的邮件同步策略（10 秒后台轮询与即时唤醒同步相结合），在保证实时性的同时降低资源消耗。

实验结果表明，NanoMail 二进制体积约 8MB，运行时内存占用低于 40MB，启动时间小于 1 秒，满足轻量级桌面应用的设计目标。本文的研究为 Rust 语言在 Windows 桌面应用开发中的应用提供了实践参考。

**关键词**：桌面客户端；Rust 语言；Slint UI 框架；OAuth2 认证；邮件同步；内存安全

---

## Abstract

With the increasing importance of email in daily work and life, users have higher requirements for real-time and convenient email notifications. Although traditional web-based Gmail is powerful, it suffers from response delays and high resource consumption. This paper designs and implements NanoMail—a lightweight Windows Gmail notification client based on the Rust programming language and Slint UI framework.

The system adopts the OAuth2.0 protocol for secure user authorization, retrieves unread email counts and user information through the Gmail API, and uses AES-256-GCM encryption combined with machine fingerprints for local encrypted storage of sensitive tokens. The system implements a hybrid-driven email synchronization strategy (combining 10-second background polling with instant wake-up synchronization), ensuring real-time responsiveness while reducing resource consumption.

Experimental results show that NanoMail has a binary size of approximately 8MB, runtime memory usage below 40MB, and startup time under 1 second, meeting the design goals of a lightweight desktop application. This research provides practical reference for the application of Rust in Windows desktop application development.

**Keywords**: Desktop Client; Rust Language; Slint UI Framework; OAuth2 Authentication; Email Synchronization; Memory Safety

---

## 第一章 绪论

### 1.1 研究背景与意义

电子邮件作为互联网时代最重要的通信工具之一，在个人通信、商务往来、学术交流等领域发挥着不可替代的作用。根据 Statista 的统计数据，2023 年全球每天发送和接收的电子邮件数量超过 3470 亿封，预计到 2025 年将达到 3760 亿封[1]。Gmail 作为全球用户量最大的电子邮件服务之一，拥有超过 18 亿活跃用户[2]。

然而，传统的 Web 端 Gmail 存在以下问题：

1. **响应延迟**：用户需要主动打开浏览器并刷新页面才能获取新邮件，无法实现真正的实时通知。
2. **资源占用**：现代 Web 应用通常需要大量内存和 CPU 资源，保持 Gmail 标签页开启会显著影响系统性能。
3. **操作繁琐**：从系统托盘或桌面快速查看未读邮件数量需要多步操作。

macOS 平台上存在名为 Gmail Notification 的轻量级通知客户端[3]，为用户提供了便捷的邮件通知体验。然而，Windows 平台缺乏类似的轻量级解决方案。市面上的邮件客户端（如 Thunderbird、Outlook、Mailspring 等）虽然功能完善，但体积庞大、资源占用高，不适合仅需邮件通知功能的用户。

基于以上背景，本文设计并实现了 NanoMail——一款面向 Windows 平台的轻量级 Gmail 通知客户端。NanoMail 采用 Rust 语言开发，具有内存安全、高性能的特点；使用 Slint 作为 UI 框架，实现现代化的用户界面；通过 OAuth2.0 协议和 AES-256-GCM 加密确保用户数据安全。

本研究的意义在于：
- 填补 Windows 平台轻量级 Gmail 通知客户端的空白
- 探索 Rust 语言在桌面应用开发中的实践方法
- 提供一种安全可靠的本地 Token 存储方案
- 为类似应用的开发提供参考和借鉴

### 1.2 国内外研究现状

在邮件客户端领域，现有产品可分为以下几类：

**1. 传统桌面邮件客户端**

Microsoft Outlook 是企业级邮件客户端的代表，提供邮件、日历、联系人等完整的办公套件功能[4]。其优点是功能全面、企业集成度高，但缺点是体积庞大（安装包超过 1GB）、资源占用高、启动速度慢。

Mozilla Thunderbird 是开源邮件客户端的代表作品[5]，支持多账户、插件扩展等功能。虽然相比 Outlook 更轻量，但仍需要超过 200MB 的磁盘空间，且界面设计相对陈旧。

**2. 现代邮件客户端**

Mailspring 是近年来新兴的跨平台邮件客户端[6]，采用 Electron 框架开发，界面美观现代。然而，Electron 应用的通病是内存占用高（通常 300MB 以上），启动速度慢。

Spark 是一款设计优秀的邮件客户端，提供智能收件箱、邮件归类等高级功能[7]。但其在 Windows 平台的支持相对较晚，且同样存在资源占用较高的问题。

**3. 轻量级通知类应用**

macOS 平台的 Gmail Notification 是一款纯通知类应用[3]，仅显示未读邮件数量和账户头像，不提供完整的邮件阅读功能。这种设计思路符合"做一件事并把它做好"的 Unix 哲学，资源占用极低。

**4. 技术发展趋势**

近年来，Rust 语言因其内存安全性和高性能特性，在系统编程领域获得广泛关注[8]。根据 Stack Overflow 2023 年开发者调查，Rust 连续 8 年被评为"最受开发者喜爱的编程语言"[9]。

在 UI 框架方面，传统的跨平台方案（如 Qt、GTK、Electron）各有优缺点。Slint 是一款新兴的声明式 UI 框架，专为 Rust 和 C++ 设计，具有轻量级、高性能、硬件加速等特点[10]。

综合分析，目前 Windows 平台缺乏一款轻量级、安全、现代化的 Gmail 通知客户端。本研究正是基于这一市场空缺，利用 Rust 和 Slint 的技术优势，设计并实现 NanoMail。

### 1.3 研究目标与内容

本文的研究目标是设计并实现一款轻量级、安全、实时的 Windows Gmail 通知客户端 NanoMail。具体研究内容包括：

**1. 基于 Rust 的高性能跨平台开发**

Rust 语言的所有权机制和借用检查器能够在编译时捕获内存安全问题，避免空指针、数据竞争等常见错误[11]。本研究将探索如何利用 Rust 的异步编程模型（Tokio 运行时）实现高效的网络通信和并发处理。

**2. OAuth2.0 授权与 Token 安全存储机制**

OAuth2.0 是目前最广泛使用的授权协议[12]。本研究将实现完整的 OAuth2.0 授权码流程，并采用 PKCE（Proof Key for Code Exchange）扩展提升安全性[13]。同时，设计基于机器指纹的密钥派生方案，使用 AES-256-GCM 算法对 Token 进行本地加密存储。

**3. Gmail API 集成与邮件同步策略**

Google Gmail API 提供了丰富的邮件操作接口[14]。本研究将实现未读邮件数量查询、用户信息获取等核心功能，并设计混合驱动的同步策略：后台低频轮询与窗口唤醒即时同步相结合，在实时性与资源消耗之间取得平衡。

**4. 现代化 UI 框架 Slint 的应用**

Slint 采用声明式语法定义 UI，支持硬件加速渲染和响应式布局[10]。本研究将探索 Slint 与 Rust 的集成方式，实现现代化的用户界面，包括磨砂玻璃效果、深色/浅色主题切换、动态状态指示等功能。

### 1.4 论文组织结构

本文共分为七章，各章节内容安排如下：

- **第一章 绪论**：介绍研究背景、国内外研究现状、研究目标与内容。
- **第二章 相关技术综述**：阐述 Rust 语言、Slint 框架、Tokio 异步运行时、OAuth2.0 协议、Gmail API、AES-GCM 加密等核心技术。
- **第三章 系统需求分析**：分析系统的功能需求、非功能需求，并给出用例图和场景描述。
- **第四章 系统设计**：详细描述系统架构、各模块设计、数据存储设计、安全设计和 UI 设计。
- **第五章 系统实现**：阐述核心功能的具体实现方法，包括关键代码分析。
- **第六章 系统测试**：介绍测试环境、测试方法、测试用例和测试结果。
- **第七章 总结与展望**：总结研究工作，分析创新点与不足，展望未来改进方向。

---

## 第二章 相关技术综述

### 2.1 Rust 语言概述

Rust 是一门由 Mozilla 主导开发的系统级编程语言，于 2010 年首次公开，2015 年发布 1.0 稳定版本[8]。Rust 的设计目标是在保证内存安全的前提下，提供与 C/C++ 相当的性能。

#### 2.1.1 所有权机制

Rust 最核心的特性是所有权（Ownership）机制。在 Rust 中，每个值都有一个明确的所有者（Owner），当所有者离开作用域时，值会被自动释放[11]。这种机制避免了手动内存管理的复杂性，同时消除了垃圾回收器带来的性能开销。

所有权规则包括：
1. Rust 中每个值都有一个所有者
2. 一个值在任一时刻只能有一个所有者
3. 当所有者离开作用域时，值将被丢弃

#### 2.1.2 借用检查器

借用（Borrowing）是 Rust 的另一核心概念。借用检查器在编译时验证引用的有效性，确保：
- 引用的生命周期不超过被引用数据的生命周期
- 在同一作用域内，要么只有一个可变引用，要么有多个不可变引用

这些规则在编译时强制执行，有效防止了数据竞争和悬垂指针等问题。

#### 2.1.3 零成本抽象

Rust 遵循"零成本抽象"原则：高级抽象不会带来运行时开销。例如，Rust 的泛型在编译时进行单态化（Monomorphization），生成针对具体类型的专用代码，性能与手写特定类型代码相当。

#### 2.1.4 Cargo 包管理

Cargo 是 Rust 的官方包管理器和构建工具，提供依赖管理、项目构建、测试运行、文档生成等功能[15]。crates.io 是 Rust 的官方包仓库，截至 2024 年已有超过 14 万个开源库。

### 2.2 Slint UI 框架

Slint（原名 SixtyFPS）是一款面向嵌入式和桌面应用的声明式 UI 框架，支持 Rust、C++ 和 JavaScript[10]。

#### 2.2.1 声明式 UI 语法

Slint 使用 `.slint` 文件定义用户界面，语法简洁直观：

```slint
component Button inherits Rectangle {
    in property <string> text;
    callback clicked;
    
    Text { text: root.text; }
    TouchArea { clicked => { root.clicked(); } }
}
```

这种声明式语法将 UI 结构与业务逻辑分离，提高代码可维护性。

#### 2.2.2 硬件加速渲染

Slint 支持多种渲染后端，包括 FemtoVG（基于 OpenGL）、Skia 和软件渲染。FemtoVG 利用 GPU 加速实现高性能渲染，特别适合动画和复杂图形效果。

#### 2.2.3 跨平台支持

Slint 支持 Windows、macOS、Linux 以及嵌入式 Linux 平台，一套代码可编译到多个目标平台。

### 2.3 Tokio 异步运行时

Tokio 是 Rust 生态中最流行的异步运行时，提供异步 I/O、定时器、同步原语等功能[16]。

#### 2.3.1 非阻塞 I/O

传统的阻塞 I/O 模型中，每个 I/O 操作都会阻塞当前线程。Tokio 采用非阻塞 I/O 模型，单个线程可以处理大量并发连接，大幅提升资源利用率。

#### 2.3.2 多线程运行时

Tokio 的多线程运行时采用工作窃取（Work-stealing）调度算法，自动在多个 CPU 核心间平衡负载。任务（Task）是轻量级的执行单元，创建和切换开销远低于操作系统线程。

#### 2.3.3 select! 宏

`select!` 宏允许同时等待多个异步操作，当任一操作完成时返回：

```rust
tokio::select! {
    _ = timer.tick() => { /* 定时器触发 */ }
    _ = trigger.notified() => { /* 手动触发 */ }
}
```

这种模式非常适合实现"定时轮询 + 手动触发"的混合驱动策略。

### 2.4 OAuth2.0 协议

OAuth2.0 是一个授权框架，允许第三方应用在用户授权的情况下访问其资源，而无需获取用户密码[12]。

#### 2.4.1 授权码流程

授权码流程（Authorization Code Flow）是最安全的 OAuth2.0 授权方式，适用于有后端服务器的应用。流程如下：

1. 客户端将用户重定向到授权服务器
2. 用户在授权服务器上完成身份验证并同意授权
3. 授权服务器将用户重定向回客户端，附带授权码
4. 客户端使用授权码向授权服务器请求访问令牌
5. 授权服务器返回访问令牌和刷新令牌

#### 2.4.2 PKCE 扩展

PKCE（Proof Key for Code Exchange）是 OAuth2.0 的安全扩展，专为公共客户端（如移动应用、桌面应用）设计[13]。PKCE 通过引入 code_verifier 和 code_challenge 参数，防止授权码被截获后被恶意使用。

流程简述：
1. 客户端生成随机的 code_verifier
2. 计算 code_challenge = SHA256(code_verifier)
3. 授权请求中包含 code_challenge
4. Token 请求中包含 code_verifier
5. 授权服务器验证 SHA256(code_verifier) == code_challenge

#### 2.4.3 Token 管理

OAuth2.0 定义了两种令牌：
- **Access Token**：用于访问受保护资源，有效期较短（通常 1 小时）
- **Refresh Token**：用于获取新的 Access Token，有效期较长

良好的 Token 管理策略应包括：自动检测过期、自动刷新、安全存储等。

### 2.5 Gmail API

Gmail API 是 Google 提供的 RESTful 接口，允许开发者读取和发送邮件、管理标签、访问用户信息等[14]。

#### 2.5.1 Labels API

Gmail 的 Labels API 提供标签管理功能。每个标签包含 `messagesTotal`（总邮件数）和 `messagesUnread`（未读邮件数）字段，可直接获取精确的未读数：

```
GET https://gmail.googleapis.com/gmail/v1/users/me/labels/INBOX
```

#### 2.5.2 UserInfo 端点

Google 的 UserInfo 端点提供用户基本信息，包括邮箱、姓名、头像等：

```
GET https://www.googleapis.com/oauth2/v3/userinfo
```

此端点需要 `userinfo.profile` 或 `userinfo.email` 权限。

### 2.6 AES-GCM 加密算法

AES-GCM（Galois/Counter Mode）是一种高效的认证加密算法，同时提供机密性和完整性保护[17]。

#### 2.6.1 工作原理

AES-GCM 结合了 CTR 计数器模式和 GMAC 消息认证码：
- CTR 模式将 AES 转换为流密码，支持并行加密
- GMAC 提供消息认证，检测任何篡改

加密过程产生密文和认证标签（Authentication Tag），解密时验证标签确保数据完整性。

#### 2.6.2 密钥派生

为避免硬编码密钥，本系统采用密钥派生函数（KDF）从机器指纹生成加密密钥。Argon2 是目前最强的密码哈希函数之一，获得了 2015 年 Password Hashing Competition 冠军[18]。

派生过程：
1. 读取 Windows 注册表中的 MachineGuid
2. 使用 Argon2id 算法派生 256 位密钥
3. 密钥仅存在于内存中，不持久化存储

---

## 第三章 系统需求分析

### 3.1 功能需求

通过对目标用户群体的调研分析，确定 NanoMail 的核心功能需求如下：

| 编号 | 功能需求 | 优先级 | 描述 |
|------|----------|--------|------|
| FR-1 | 多账户登录 | 高 | 支持添加多个 Gmail 账户，通过 OAuth2.0 安全授权 |
| FR-2 | 未读数显示 | 高 | 实时显示各账户的未读邮件数量 |
| FR-3 | 用户信息展示 | 中 | 显示用户头像、昵称，支持头像本地缓存 |
| FR-4 | 系统托盘 | 高 | 最小化到系统托盘，左键切换窗口，右键显示菜单 |
| FR-5 | 主题切换 | 中 | 支持深色/浅色主题，偏好自动持久化 |
| FR-6 | Token 加密 | 高 | 使用 AES-256-GCM 加密存储敏感 Token |
| FR-7 | 快速访问 | 中 | 一键打开 Gmail 网页版 |
| FR-8 | 状态指示 | 中 | 通过颜色指示登录状态和同步状态 |

**FR-1 多账户登录**：用户可以添加多个 Gmail 账户，系统通过 OAuth2.0 协议进行安全授权，不存储用户密码。授权完成后自动获取用户邮箱地址和显示名称。

**FR-2 未读数显示**：系统采用混合驱动策略同步未读数：
- 后台每 10 秒低功耗轮询一次
- 窗口显示时立即触发一次同步
确保用户看到的数据始终是最新的。

**FR-3 用户信息展示**：从 Google UserInfo API 获取用户头像和姓名，头像下载后缓存至本地目录，避免重复网络请求。

**FR-4 系统托盘**：程序启动后在系统托盘显示图标。左键点击切换主窗口显示/隐藏，右键显示快捷菜单（打开 Gmail、关于、退出）。

**FR-5 主题切换**：支持深色和浅色两种主题，用户可通过界面按钮手动切换，偏好设置自动保存到配置文件。

**FR-6 Token 加密**：Access Token 和 Refresh Token 使用 AES-256-GCM 算法加密后存储。加密密钥从机器指纹派生，确保 Token 无法在其他设备上解密。

### 3.2 非功能需求

| 编号 | 非功能需求 | 指标 | 描述 |
|------|------------|------|------|
| NFR-1 | 轻量级 | 二进制 < 10MB | 优化编译选项，移除调试符号 |
| NFR-2 | 低内存 | 运行时 < 50MB | 合理管理资源，避免内存泄漏 |
| NFR-3 | 快速启动 | < 1 秒 | 延迟加载非关键资源 |
| NFR-4 | 安全性 | Token 加密、HTTPS | 所有敏感数据加密，网络传输使用 TLS |
| NFR-5 | 可靠性 | 网络重连 | 网络断开时自动重试，使用指数退避 |
| NFR-6 | 可用性 | 界面友好 | 简洁直观的用户界面，状态反馈清晰 |

**NFR-1 轻量级**：通过以下手段优化二进制体积：
- 启用 LTO（Link-Time Optimization）
- 使用 opt-level='z' 优化体积
- Strip 移除调试符号
- 设置 codegen-units=1 减少冗余

**NFR-4 安全性**：
- OAuth2.0 + PKCE 防止授权码截获
- AES-256-GCM 加密 Token
- 机器指纹派生密钥防止跨设备窃取
- 所有 API 调用使用 HTTPS

**NFR-5 可靠性**：
- 网络检测使用 Google 204 端点
- 失败时采用指数退避重试（1s, 2s, 4s, ...）
- Token 过期自动刷新

### 3.3 用例分析

#### 3.3.1 主要用例

系统主要用例包括：
1. **添加账户**：用户点击添加按钮，完成 OAuth2.0 授权，账户添加成功
2. **查看未读数**：用户打开主窗口，查看各账户的未读邮件数量
3. **切换主题**：用户点击主题切换按钮，界面在深色/浅色间切换
4. **打开 Gmail**：用户点击邮件图标，浏览器打开 Gmail 网页版
5. **最小化到托盘**：用户点击最小化按钮，窗口隐藏到系统托盘
6. **从托盘恢复**：用户点击托盘图标，主窗口重新显示

#### 3.3.2 典型场景

**场景 1：首次使用**
1. 用户双击 NanoMail.exe 启动应用
2. 主窗口显示在屏幕右下角（托盘附近）
3. 用户点击"+"按钮添加 Gmail 账户
4. 浏览器自动打开 Google 授权页面
5. 用户登录并同意授权
6. 浏览器显示"授权成功"页面
7. 主窗口自动更新，显示账户头像、昵称和未读数

**场景 2：日常使用**
1. 系统启动时 NanoMail 自动运行（可选）
2. 应用在后台每 10 秒同步一次未读数
3. 用户看到托盘图标后点击左键
4. 主窗口弹出，立即触发同步，显示最新未读数
5. 用户确认无重要邮件后点击最小化按钮
6. 窗口隐藏，应用继续后台运行

---

## 第四章 系统设计

### 4.1 系统架构设计

NanoMail 采用分层架构设计，从上到下分为四层：表现层、业务逻辑层、数据访问层、系统集成层。

```
┌─────────────────────────────────────────────────┐
│                   表现层 (UI)                    │
│        Slint UI (main.slint, components/)       │
├─────────────────────────────────────────────────┤
│                 业务逻辑层 (Core)                │
│    main.rs │ sync/ │ mail/gmail/ │ tray/       │
├─────────────────────────────────────────────────┤
│                 数据访问层 (Data)                │
│         config/ │ storage │ crypto             │
├─────────────────────────────────────────────────┤
│                系统集成层 (Integration)          │
│      utils/ │ http_client │ machine_id         │
└─────────────────────────────────────────────────┘
```

**表现层**：负责用户界面渲染和交互。使用 Slint 框架定义界面布局、组件样式和事件回调。

**业务逻辑层**：实现核心业务功能。包括应用生命周期管理（main.rs）、邮件同步引擎（sync/）、Gmail API 调用（mail/gmail/）、系统托盘管理（tray/）。

**数据访问层**：负责数据持久化和安全存储。包括配置文件管理（config/）、账户存储（storage）、Token 加密解密（crypto）。

**系统集成层**：提供与操作系统和外部服务的集成。包括 HTTP 连接池（http_client）、机器指纹获取（machine_id）等工具函数。

### 4.2 模块设计

#### 4.2.1 主程序模块（main.rs）

主程序模块是应用的入口点，负责：
1. 初始化日志系统
2. 创建 Tokio 异步运行时
3. 创建 Slint 主窗口
4. 加载已保存的账户
5. 初始化系统托盘
6. 绑定 UI 回调函数
7. 启动同步引擎
8. 运行 Slint 事件循环
9. 处理优雅退出

主程序采用"协调者"模式，本身不包含复杂业务逻辑，而是协调各模块协同工作。

#### 4.2.2 同步引擎模块（sync/）

同步引擎采用混合驱动策略：

```rust
pub struct SyncEngine {
    running: Arc<RwLock<bool>>,      // 运行状态
    rt_handle: tokio::runtime::Handle, // Tokio 运行时
    trigger: Arc<Notify>,             // 手动触发信号
}
```

核心同步循环使用 `tokio::select!` 同时监听定时器和手动触发：

```rust
tokio::select! {
    _ = timer.tick() => { /* 定时触发 */ }
    _ = trigger.notified() => { /* 手动触发 */ }
}
```

当窗口显示时调用 `trigger_sync()` 方法，通过 `Notify` 发送信号立即唤醒同步循环。

#### 4.2.3 邮件模块（mail/gmail/）

邮件模块包含以下子模块：

- **api.rs**：Gmail API 客户端，封装未读数查询、用户信息获取等接口
- **oauth.rs**：OAuth2.0 认证流程实现
- **token.rs**：Token 管理器，自动检测过期和刷新
- **types.rs**：数据结构定义（GmailAccount）

OAuth2.0 认证流程：
1. 生成随机端口（8080-8089）的本地回调 URL
2. 生成 PKCE code_verifier 和 code_challenge
3. 构造授权 URL 并打开浏览器
4. 启动本地 HTTP 服务器等待回调
5. 验证 CSRF state
6. 使用授权码交换 Token
7. 获取用户信息
8. 加密保存账户

#### 4.2.4 配置模块（config/）

配置模块管理应用设置和安全存储：

- **mod.rs**：配置文件加载/保存（TOML 格式）
- **crypto.rs**：AES-256-GCM 加密/解密
- **storage.rs**：账户持久化
- **oauth_config.rs**：OAuth 凭据管理

Token 加密格式：
```
encrypted:BASE64(nonce[12 bytes] + ciphertext + tag[16 bytes])
```

Serde 自定义序列化器在保存时自动加密，反序列化时保持加密状态（按需解密）。

#### 4.2.5 系统托盘模块（tray/）

托盘模块负责：
- 创建系统托盘图标
- 处理鼠标事件（左键点击、右键菜单）
- 计算窗口显示位置（屏幕右下角）

托盘事件通过 `mpsc::channel` 发送到主线程处理，确保 UI 更新在 Slint 事件循环中执行。

### 4.3 数据存储设计

#### 4.3.1 存储目录结构

```
%APPDATA%/NanoMail/
├── config.toml          # 应用配置
├── accounts/            # 账户数据
│   └── {email}.toml     # 单个账户（Token 已加密）
└── avatars/             # 头像缓存
    └── {email}.jpg      # 用户头像
```

#### 4.3.2 账户数据结构

```toml
email = "user@gmail.com"
display_name = "User Name"
access_token = "encrypted:BASE64..."  # 加密的 Access Token
refresh_token = "encrypted:BASE64..." # 加密的 Refresh Token
expires_at = "2024-01-01T12:00:00Z"   # 过期时间
is_active = true
```

### 4.4 安全设计

#### 4.4.1 OAuth2.0 授权流程

```
┌──────┐      ┌──────────┐      ┌────────────┐
│ User │      │ NanoMail │      │   Google   │
└──┬───┘      └────┬─────┘      └─────┬──────┘
   │   1. 点击添加  │                  │
   │──────────────>│                  │
   │               │ 2. 生成 PKCE     │
   │               │ 3. 打开浏览器    │
   │               │─────────────────>│
   │               │                  │ 4. 用户登录授权
   │<─────────────────────────────────│
   │               │<─────────────────│
   │               │ 5. 回调带 code   │
   │               │ 6. 交换 Token    │
   │               │─────────────────>│
   │               │<─────────────────│
   │               │ 7. 加密存储      │
   │<──────────────│                  │
   │   8. 显示账户 │                  │
```

#### 4.4.2 密钥派生方案

```
MachineGUID (Windows Registry)
        │
        ▼
   Argon2id(salt="NanoMail", memory=64MB, iterations=3)
        │
        ▼
   256-bit Encryption Key
```

使用 Windows 机器指纹作为密钥派生输入，确保：
- 每台机器生成不同的密钥
- Token 无法在其他设备上解密
- 密钥不存储在磁盘上

### 4.5 UI 设计

#### 4.5.1 主界面布局

主界面分为三个区域：
1. **标题栏**（60px）：应用名称、状态指示、主题切换、快捷按钮
2. **账户列表**（动态高度）：显示已添加的账户卡片
3. **操作栏**（60px）：添加账户、反馈、最小化按钮

#### 4.5.2 组件设计

- **IconButton**：图标按钮，支持 hover 效果
- **Badge**：未读数徽章，动态颜色
- **AccountCard**：账户卡片，显示头像、昵称、未读数

#### 4.5.3 主题系统

通过全局 `Theme` 单例管理颜色变量，支持一键切换深色/浅色模式：

```slint
global Theme {
    in-out property <bool> is-dark: false;
    out property <color> background: is-dark ? #1a1a2e : #ffffff;
    out property <color> text-primary: is-dark ? #ffffff : #1a1a2e;
    // ...
}
```

---

## 第五章 系统实现

### 5.1 开发环境

| 项目 | 配置 |
|------|------|
| 操作系统 | Windows 11 Pro 23H2 |
| 开发语言 | Rust 2024 Edition |
| 包管理器 | Cargo 1.83.0 |
| IDE | Visual Studio Code + rust-analyzer |
| UI 框架 | Slint 1.8.0 |
| 异步运行时 | Tokio 1.38 |
| HTTP 客户端 | Reqwest 0.12 |

### 5.2 核心功能实现

#### 5.2.1 OAuth2 认证实现

OAuth2 认证的核心代码位于 `src/mail/gmail/oauth.rs`。

**步骤 1：生成 PKCE 挑战**

```rust
let (pkce_challenge, pkce_verifier) = PkceCodeChallenge::new_random_sha256();
```

**步骤 2：构造授权 URL**

```rust
let (auth_url, csrf_state) = client
    .authorize_url(CsrfToken::new_random)
    .add_scopes(scopes)
    .set_pkce_challenge(pkce_challenge)
    .url();
```

**步骤 3：本地服务器接收回调**

使用 `tiny_http` 库启动轻量级 HTTP 服务器：

```rust
let server = Server::http("127.0.0.1:8080")?;
for request in server.incoming_requests() {
    // 解析 code 和 state
    // 返回成功/错误页面
}
```

**步骤 4：交换 Token**

```rust
let token_response = client
    .exchange_code(code)
    .set_pkce_verifier(verifier)
    .request_async(oauth2::reqwest::async_http_client)
    .await?;
```

#### 5.2.2 Token 加密存储实现

加密核心代码位于 `src/config/crypto.rs`。

**加密流程**：

```rust
pub fn encrypt_token(plain: &str) -> Result<String> {
    // 1. 从机器指纹派生密钥
    let key = machine_id::derive_encryption_key()?;
    
    // 2. 创建 AES-256-GCM 密码器
    let cipher = Aes256Gcm::new(&key.into());
    
    // 3. 生成随机 nonce
    let nonce = Aes256Gcm::generate_nonce(&mut OsRng);
    
    // 4. 加密
    let ciphertext = cipher.encrypt(&nonce, plain.as_bytes())?;
    
    // 5. 组合并编码
    let combined = [nonce.as_slice(), &ciphertext].concat();
    Ok(format!("encrypted:{}", BASE64.encode(&combined)))
}
```

**解密流程**：

```rust
pub fn decrypt_token(encrypted: &str) -> Result<String> {
    // 1. 检查前缀
    let data = encrypted.strip_prefix("encrypted:")?;
    
    // 2. Base64 解码
    let combined = BASE64.decode(data)?;
    
    // 3. 分离 nonce 和密文
    let (nonce, ciphertext) = combined.split_at(12);
    
    // 4. 派生密钥并解密
    let key = machine_id::derive_encryption_key()?;
    let cipher = Aes256Gcm::new(&key.into());
    let plaintext = cipher.decrypt(nonce.into(), ciphertext)?;
    
    Ok(String::from_utf8(plaintext)?)
}
```

#### 5.2.3 邮件同步实现

同步引擎核心代码位于 `src/sync/mod.rs`。

**混合驱动同步循环**：

```rust
loop {
    tokio::select! {
        _ = timer.tick() => {
            tracing::info!("⏰ 定时器触发同步");
        }
        _ = trigger.notified() => {
            tracing::info!("🔔 手动触发同步");
            timer.reset(); // 重置定时器避免重复同步
        }
    }
    
    // 执行同步
    for account in load_accounts()? {
        match sync_account_info(&account).await {
            Ok((info, updated)) => {
                callback(email, Ok(info));
                if let Some(acc) = updated {
                    save_account(&acc)?; // Token 被刷新
                }
            }
            Err(e) => callback(email, Err(e.to_string())),
        }
    }
}
```

**网络检测与重试**：

```rust
async fn ensure_network_available() -> Result<bool> {
    const CHECK_URL: &str = "https://www.google.com/generate_204";
    let mut delay = 1;
    
    for attempt in 1..=4 {
        match client.get(CHECK_URL).send().await {
            Ok(resp) if resp.status().is_success() => return Ok(true),
            _ => {
                tokio::time::sleep(Duration::from_secs(delay)).await;
                delay = min(delay * 2, 30); // 指数退避
            }
        }
    }
    Err(anyhow!("网络不可用"))
}
```

#### 5.2.4 系统托盘实现

托盘核心代码位于 `src/tray/mod.rs`。

**创建托盘图标**：

```rust
pub fn create_tray_icon(tx: Sender<TrayCommand>) -> Result<TrayIcon> {
    let icon = load_icon(TrayIconState::Normal)?;
    let (menu, menu_ids) = create_menu_with_ids()?;
    
    let tray = TrayIconBuilder::new()
        .with_menu(Box::new(menu))
        .with_tooltip("NanoMail - Gmail 通知客户端")
        .with_icon(icon)
        .build()?;
    
    // 启动事件监听线程
    std::thread::spawn(move || {
        run_event_loop(menu_ids, tx);
    });
    
    Ok(tray)
}
```

**窗口位置计算**：

```rust
pub fn show_window_near_tray<T: ComponentHandle>(window: &T) {
    let (screen_w, screen_h) = get_primary_screen_size()?;
    let (win_w, win_h) = (380, 400);
    
    // 右下角，留出任务栏空间
    let x = screen_w - win_w - 97;
    let y = screen_h - win_h - 50;
    
    window.set_position(PhysicalPosition::new(x, y));
    window.show()?;
}
```

### 5.3 构建优化

`Cargo.toml` 中的 Release 配置：

```toml
[profile.release]
opt-level = 'z'   # 体积优先
lto = true        # 链接时优化
codegen-units = 1 # 单编译单元
strip = true      # 移除符号
panic = 'abort'   # 简化 panic 处理
```

优化效果：
- Debug 构建：约 20MB
- Release 构建：约 3MB（减少 84%）

---

## 第六章 系统测试

### 6.1 测试环境

| 项目 | 配置 |
|------|------|
| 测试机器 | Inter i5-11400H , 16GB RAM |
| 操作系统 | Windows 11 Pro 23H2 |
| 网络环境 | 100Mbps 宽带 |

### 6.2 单元测试

项目包含多个单元测试模块：

```bash
cargo test
```

| 模块 | 测试用例数 | 通过率 |
|------|-----------|--------|
| crypto | 6 | 100% |
| types | 5 | 100% |
| sync | 2 | 100% |
| oauth | 2 | 100% |

主要测试内容：
- 加密/解密往返一致性
- Token 格式验证
- 账户序列化/反序列化
- 同步引擎创建

### 6.3 功能测试

| 测试项 | 预期结果 | 实际结果 | 状态 |
|--------|----------|----------|------|
| 添加账户 | 浏览器打开授权页，授权后账户显示 | 符合预期 | ✅ |
| 未读数同步 | 显示正确的未读邮件数量 | 符合预期 | ✅ |
| 主题切换 | 界面颜色正确切换 | 符合预期 | ✅ |
| 托盘左键 | 窗口显示/隐藏切换 | 符合预期 | ✅ |
| 托盘右键 | 显示快捷菜单 | 符合预期 | ✅ |
| 打开 Gmail | 默认浏览器打开 Gmail | 符合预期 | ✅ |
| 网络断开 | 显示错误状态，恢复后自动重连 | 符合预期 | ✅ |

### 6.4 性能测试

| 指标 | 目标值 | 实测值 | 状态 |
|------|--------|--------|------|
| 二进制体积 | < 10MB | 2.41MB | ✅ |
| 启动时间 | < 1s | 0.6s | ✅ |
| 内存占用（空闲） | < 50MB | 35MB | ✅ |
| 内存占用（同步中） | < 60MB | 42MB | ✅ |
| CPU 占用（空闲） | < 1% | 0.1% | ✅ |

### 6.5 安全测试

| 测试项 | 方法 | 结果 |
|--------|------|------|
| Token 加密强度 | 使用 AES-GCM 标准测试向量验证 | 通过 |
| 跨设备解密 | 复制账户文件到另一台机器 | 解密失败（符合预期） |
| CSRF 防护 | 篡改 state 参数 | 授权被拒绝（符合预期） |

### 6.6 测试结果分析

测试结果表明，NanoMail 满足设计目标：
- 所有功能模块工作正常
- 性能指标全部达标
- 安全机制有效

---

## 第七章 总结与展望

### 7.1 工作总结

本文设计并实现了 NanoMail——一款基于 Rust 语言和 Slint UI 框架的轻量级 Windows Gmail 通知客户端。主要完成了以下工作：

1. **系统设计**：采用分层架构，将表现层、业务逻辑层、数据访问层、系统集成层清晰分离，提高代码可维护性。

2. **OAuth2.0 认证**：实现完整的授权码流程，采用 PKCE 扩展提升安全性，支持多账户登录。

3. **安全存储**：设计基于机器指纹的密钥派生方案，使用 AES-256-GCM 算法加密 Token，防止跨设备窃取。

4. **混合同步策略**：结合后台低频轮询与即时唤醒同步，在实时性与资源消耗间取得平衡。

5. **现代化 UI**：使用 Slint 框架实现简洁美观的用户界面，支持深色/浅色主题切换。

### 7.2 创新点

1. **Rust + Slint 的 Windows 桌面应用实践**：探索了 Rust 语言在 Windows 桌面应用开发中的应用方法，为类似项目提供参考。

2. **基于机器指纹的本地 Token 安全存储方案**：使用 Windows MachineGUID 派生加密密钥，Token 无法在其他设备上解密。

3. **混合驱动的高效邮件同步策略**：通过 Tokio `select!` 宏实现定时轮询与手动触发的无缝切换。

### 7.3 不足与展望

**当前局限性**：
- 仅支持 Gmail，不支持 Outlook、QQ 邮箱等其他服务商
- 仅支持 Windows 平台，不支持 macOS 和 Linux。
- 功能较为简单，仅显示未读数，不支持邮件预览

**未来改进方向**：
1. **多服务商支持**：扩展支持 Outlook、QQ 邮箱、163 邮箱等
2. **跨平台支持**：利用 Slint 的跨平台特性，适配 macOS 和 Linux
3. **桌面通知**：集成 Windows 通知中心，新邮件到达时推送通知
4. **邮件预览**：支持查看邮件主题和摘要
5. **快捷回复**：支持简单的邮件回复功能

---

## 参考文献

[1] Statista. Number of sent and received e-mails per day worldwide from 2017 to 2026 [EB/OL]. https://www.statista.com/statistics/456500/daily-number-of-e-mails-worldwide/, 2024.

[2] Google. Gmail: Free Email Service by Google [EB/OL]. https://www.google.com/gmail/about/, 2024.

[3] crayonape. Gmail Notification for macOS [EB/OL]. https://github.com/crayonape/Gmail-Notification, 2023.

[4] Microsoft. Microsoft Outlook - Email and Calendar [EB/OL]. https://www.microsoft.com/en-us/microsoft-365/outlook/, 2024.

[5] Mozilla. Thunderbird - Free Email Application [EB/OL]. https://www.thunderbird.net/, 2024.

[6] Mailspring. The Best Free Email App [EB/OL]. https://getmailspring.com/, 2024.

[7] Readdle. Spark - Email App for Teams [EB/OL]. https://sparkmailapp.com/, 2024.

[8] Klabnik S, Nichols C. The Rust Programming Language [M]. No Starch Press, 2023.

[9] Stack Overflow. 2023 Developer Survey [EB/OL]. https://survey.stackoverflow.co/2023/, 2023.

[10] Slint. Slint - Declarative UI Toolkit [EB/OL]. https://slint.dev/, 2024.

[11] Blandy J, Orendorff J, Tindall L. Programming Rust: Fast, Safe Systems Development [M]. O'Reilly Media, 2021.

[12] Hardt D. RFC 6749: The OAuth 2.0 Authorization Framework [S]. IETF, 2012.

[13] Sakimura N, Bradley J, Agarwal N. RFC 7636: Proof Key for Code Exchange by OAuth Public Clients [S]. IETF, 2015.

[14] Google. Gmail API Documentation [EB/OL]. https://developers.google.com/gmail/api, 2024.

[15] Rust Team. The Cargo Book [EB/OL]. https://doc.rust-lang.org/cargo/, 2024.

[16] Tokio Team. Tokio - An asynchronous runtime for Rust [EB/OL]. https://tokio.rs/, 2024.

[17] Dworkin M. NIST SP 800-38D: Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC [S]. NIST, 2007.

[18] Biryukov A, Dinu D, Khovratovich D. Argon2: the memory-hard function for password hashing and other applications [C]. Euro S&P, 2016.

---

## 致谢

本论文的完成得益于多方面的支持与帮助。

首先，感谢我的指导老师在论文选题、研究方向和撰写过程中给予的悉心指导和宝贵建议。老师严谨的治学态度和丰富的专业知识使我受益匪浅。

其次，感谢 Rust 社区、Slint 团队以及众多开源项目的贡献者。NanoMail 的实现离不开 Tokio、Reqwest、oauth2、aes-gcm 等优秀的开源库。

感谢同学们在学习和生活中的互相帮助与鼓励，陪伴我度过了充实的大学时光。

最后，感谢家人多年来的养育之恩和默默支持，是你们的爱与付出让我能够专心追求学业。

---

## 附录

### 附录 A：核心源代码

#### A.1 OAuth2 认证核心代码（oauth.rs 节选）

```rust
pub async fn authenticate() -> Result<GmailAccount> {
    // 1. 加载配置
    let config = OAuthConfig::load()?;
    
    // 2. 生成授权 URL（带 PKCE）
    let (auth_url, csrf_state, pkce_verifier, port) = build_auth_url(&config)?;
    
    // 3. 启动本地服务器
    let (code_tx, code_rx) = oneshot::channel();
    std::thread::spawn(move || start_local_server(port, code_tx));
    
    // 4. 打开浏览器
    webbrowser::open(auth_url.as_str())?;
    
    // 5. 等待回调
    let (code, state) = tokio::time::timeout(
        Duration::from_secs(60),
        code_rx
    ).await??;
    
    // 6. 验证 CSRF
    if state.secret() != csrf_state.secret() {
        anyhow::bail!("CSRF 验证失败");
    }
    
    // 7. 交换 Token
    let token = exchange_code_for_token(code, pkce_verifier, &config, port).await?;
    
    // 8. 获取用户信息
    let (email, name) = fetch_user_info(token.access_token().secret()).await?;
    
    // 9. 创建并保存账户
    let account = GmailAccount::new(email, name, ...)?;
    storage::save_account(&account)?;
    
    Ok(account)
}
```

#### A.2 AES-GCM 加密核心代码（crypto.rs 节选）

```rust
pub fn encrypt_token(plain: &str) -> Result<String> {
    let key = machine_id::derive_encryption_key()?;
    let cipher = Aes256Gcm::new(&key.into());
    let nonce = Aes256Gcm::generate_nonce(&mut OsRng);
    let ciphertext = cipher.encrypt(&nonce, plain.as_bytes())?;
    
    let mut combined = Vec::with_capacity(12 + ciphertext.len());
    combined.extend_from_slice(&nonce);
    combined.extend_from_slice(&ciphertext);
    
    Ok(format!("encrypted:{}", BASE64.encode(&combined)))
}
```

### 附录 B：用户手册

#### B.1 系统要求
- Windows 10 (1809+) 或 Windows 11
- 稳定的网络连接

#### B.2 安装步骤
1. 下载 `NanoMail.exe`
2. 双击运行（无需安装）

#### B.3 首次使用
1. 点击主界面的"+"按钮
2. 在浏览器中完成 Google 授权
3. 授权成功后账户自动显示

#### B.4 日常使用
- 左键点击托盘图标：显示/隐藏窗口
- 右键点击托盘图标：显示菜单
- 点击信封图标：打开 Gmail
- 点击月亮/太阳图标：切换主题

